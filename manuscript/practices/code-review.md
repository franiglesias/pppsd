Voy a hacer un üßªü§¨ sobre por qu√© las code reviews no sirven para aprender a desarrollar bien. De hecho, las considero contraproducentes en ese aspecto. Y no solo para juniors, sino tambi√©n para senior nuevos a un proyecto.
Una asunci√≥n es que la persona que hace la petici√≥n de code review ha trabajado sola en ese pull request espec√≠fico. El primer problema que se puede ver aqu√≠ es que la revisora (o revisoras) no tiene el contexto ni del problema ni de como se ha llegado a la soluci√≥n.
De hecho, el que una persona trabaje sola en un equipo es una mala pr√°ctica. Pero eso lo tratar√© en otro momento.
Puesto que los problemas raramente tienen una soluci√≥n √∫nica y en programaci√≥n hay cienes de formas de hacer algo, la review en estas condiciones puede ser algo tremendamente subjetivo e injusto. Como desarrolladoras nos hemos encontrado muchas veces en la necesidad de aceptar...
compromisos. Por ejemplo, hacer un c√≥digo no muy limpio para no eternizarnos refactorizando cosas que no tienen que ver con la historia que tenemos en la mano en ese momento. Dir√©is: pues docum√©ntalo con un comentario. Y yo digo: la revisora no va a leer el comentario.
Pero bueno, el punto es que hay algunas decisiones que parecer√°n err√≥neas a la revisora porque le falta el contexto. Incluso cuando esas decisiones las ha tomado alguien de sobrada seniority. Hablando de lo cual‚Ä¶
El caso de persona junior que pide la review y se le tira casi todo para atr√°s porque ha hecho varias cosas ‚Äúmal‚Äù seg√∫n las revisoras. Pues esto es una mala pr√°ctica atroz. En primer lugar, porque convierte la code review en un examen de programaci√≥n que, adem√°s, es injusto.
Es injusto porque a la persona junior le falta informaci√≥n. Ojo, no digo formaci√≥n, digo informaci√≥n. De hecho, si una junior llega a una review en estas condiciones no es que le falte info, es que no se le ha dado. Se le est√° ocultando informaci√≥n.
Me explico. T√≠pica revisi√≥n: ‚Äúes que no has considerado que nosotros no lo hacemos as√≠ porque‚Ä¶‚Äù. En primer lugar, si hay condicionantes/compromisos/requisitos para hacer las cosas: ¬øpor qu√© no se ha ayudado a la persona junior a conocerlas?
Por otro lado est√° el cambio de contexto al hacer la review. T√∫ est√°s en otra cosa y tienes que cambiar tu contexto de un problema a otro, y tratar de entender que est√° pasando en ese otro contexto. ‚ÄúPero es que en la daily ya coordinamos y sabemos en qu√© est√° cada qui√©n‚Äù‚Ä¶ Ya.
Por no hablar de lo que ocurre mientras la review no se lleva a cabo. La solicitante: ¬øtiene que pararlo todo y esperar a recibir la review? Porque entonces tambi√©n sufrir√° el cambio de contexto, m√°s el marr√≥n de integrar los cambios que haya habido en paralelo.
Y eso contando con que no se hayan introducido conflictos, que tambi√©n puede pasar.
¬øSoluci√≥n a esto? Pues programaci√≥n colectiva, pairing o mobbing. ¬øPor qu√©? En primer lugar, porque compartimos el contexto, aunque vengamos con ideas diferentes. De este modo todas podemos proponer soluciones distintas que se discuten en el momento, en un contexto compartido.
Sirven para mentorizar a personas con menos experiencia , pueden hacer sus propuestas y se discuten en el momento, incluso prob√°ndola. Sirven para descubrir y aprender aquellas cosas que no est√°n documentadas (o que lo est√°n en alg√∫n lugar que no se actualiza desde hace a√±os)
¬øPero como puedes tener dos personas (o m√°s) trabajando en lo mismo? Qu√© p√©rdida de tiempo. Pues en realidad es un ahorro de tiempo. Esto del tiempo me hace gracias porque nunca (o casi nunca) se cuenta el tiempo que se pierde en la revisi√≥n y en el ir y volver con los cambios.
Es ahorro de tiempo porque en un poco m√°s (y a veces menos) del tiempo en que se completa una historia, se hace con menos problemas y menos frustraciones. Adem√°s, todas las personas que participan aprenden m√°s, lo que las har√° m√°s productivas en el futuro inmediato.
Una posible ventaja de las code review es cuando un cambio puede afectar a un entorno mayor que el equipo. Con todo, en ese caso puede que sea m√°s productivo e interesante invitar a otros implicados a una sesi√≥n de mob programming de modo que los problemas se puedan prevenir‚Ä¶
y evitar de una manera m√°s eficaz y precoz, en lugar de tener que parchear o volver atr√°s a la causa ra√≠z con el pull request hecho.
Por otro lado, en las sesiones de mob programming puede (y deber√≠a) participar gente de producto, clientes, etc. Igual no en todas o todo el tiempo, pero s√≠ cuando se tratan reglas de negocio, UI, UX, etc y/o no se comprende bien el problema en el que se est√° trabajando.
¬øLas mob programming en remoto son complicadas? Un poco, s√≠. ¬øQue a veces hay partes que realmente no har√≠a falta hacer en mob? Tambi√©n, pero gracias a haber hecho mob tenemos mejor definidas y delimitadas esas partes y de todos modos las integraremos durante una sesi√≥n de mob.
Como ves, no se trata de eliminar las code reviews ‚Äúbecause yes‚Äù, si no entender que introducir pr√°cticas (propuestas hace d√©cadas, por cierto) de trabajo en equipo permitir√°n extender el conocimiento de forma m√°s eficaz y s√≥lida a trav√©s de un aprendizaje cont√≠nuo
en lugar de hacer ‚Äúevaluaciones" en forma de code review en las que realmente no se aprende nada y act√∫an m√°s de barrera que de feedback constructivo.

(s√≠, s√≠, ya s√© que t√∫ haces las code review muy bien. Yo, siendo sinceros las hago fatal).
Por no mencionar los proyectos que tienen code reviews y est√°n plagados de bugs y problemas igualmente, demostrando que la code review no es garant√≠a de nada.
O por no mencionar el problema de las code reviews de n-muchos archivos que es humanamente imposible hacer bien, o las que solo se ocupan del code-style. O las que llevan 3000 approves porque eran dos l√≠neas.
En resumen, para aprender a desarrollar bien lo que hay que hacer es programar juntas.

üòÖ He debido pinchar en hueso con esto de las code reviews. Intentar√© contestar algunas de las ideas que han salido y matizar el üßª anterior. Prefiero hacerlo as√≠, que es m√°s f√°cil enlazar un argumento largo. Vamos a ello.
En primer lugar, el punto del hilo es que las code review no sirven para aprender y mucho menos para que alguien junior aprenda. De hecho, ni siquiera son buenas para entender un proyecto grande, necesitas otras estrategias de aprendizaje.
Dicho esto, las CR se supone que sirven para garantizar la calidad del c√≥digo, evitar errores (particularmente de integraci√≥n) y aumentar la confianza en el c√≥digo que se mezcla y se despliega.
No he entrado en ese punto particular, aunque mi opini√≥n es que las CR no tienen mucho sentido en el contexto de equipos dentro de una empresa (s√≠ en open source y tal).¬øPor qu√© digo esto?
Porque todas las ventajas que se se√±alan aumentan su eficacia si se hacen antes, no a posteriori.  Como ha mencionado @javisan81 , las PR/CR aumentan el WIP. De hecho, son constraints de libro. La definition of done deber√≠a ser ‚Äúfeature que el usuario puede usar‚Äù
La asunci√≥n b√°sica que estamos haciendo es que las PR se hacen porque trabajamos individualmente. Hablamos de equipos, pero en muchos casos el trabajo concreto se realiza en soledad y es despu√©s de ‚Äúfinalizado‚Äù cuando se hace la review. Esto tiene varios problemas.
Por ejemplo, @ntoniocp se√±ala ‚Äúalguien que no est√© tan metido en el problema como t√∫ ayuda a tener menos bias‚Äù. Para empezar: ¬øPor qu√© solo una persona deber√≠a estar trabajando en un problema sola? SI sabemos que va a haber bias, ¬øpor qu√© no estar dos √≥ m√°s trabajando y prevenir
ese bias desde el inicio?@ntoniocp menciona la capacidad de la CR para abrir debate y llegar a acuerdos sobre como escribir software. Pero en la CR el c√≥digo ya est√° escrito. ¬øPor qu√© no mover ese tipo de debates al principio de los proyectos y durante el desarrollo?
Estoy de acuerdo en que una forma de trabajo no debe ser reemplazada por la otra porque s√≠ y sin tomar medidas adecuadas (pero ese no era el punto del üßª).
Para mi el feedback en las CR llega tarde y mal. El editor est√° en modo ‚Äúacabar la tarea‚Äù y ha invertido tiempo y esfuerzo (coste hundido que le llaman), lo que hace que la CR sea m√°s vista como una evaluaci√≥n que como una contribuci√≥n.
Por otro lado, ¬øpor qu√© alargar el tiempo de feedback cuando puedes hacerlo inmediatamente? Hay un gr√°fico sobre los ciclos de feedback (de Kent Beck) que es muy ilustrativo sobre esto. Ensemble-programming proporciona feedback instant√°neo en el momento requerido.
@raularabaolaza dice ‚Äúpero es que no es tu c√≥digo, es el c√≥digo del equipo‚Äù‚Ä¶ Entonces, ¬øpor qu√© no lo escribe el equipo en conjunto en lugar de hacer que una dev lo haga en solitario para que el equipo juzgue si es aceptable o no?
Bueno, seguro que me dejo un mont√≥n de cosas y algunas ideas sin comentar, pero a grandes rasgos estas son las ideas que quer√≠a expresar. Buena semana